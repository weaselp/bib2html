#!/usr/bin/perl

use strict;
use warnings;
use File::Path;
use File::Temp;
use Text::BibTeX;
#use Text::Template;
use t2h;
use Data::Dumper;

my $DO_SELECTED_ONLY = 1;

package Item;

sub new {
    my ($class, $bibentry) = @_;
    my $self = {'bibentry' => $bibentry};
    bless $self, $class;
    $self;
}

sub exists {
    my ($self, $field) = @_;
    return 1 if $self->{'bibentry'}->exists($field);
    return 1 if grep {$_ eq $field} qw{f_authors f_atitle};
    return 0;
}

sub get_plain {
    my ($self, $field) = @_;

    return $self->{'bibentry'}->get($field)
        if ($self->{'bibentry'}->exists($field));

    if ($field eq 'f_authors') {
        return $self->{'bibentry'}->format_authors;
    } elsif ($field eq 'f_atitle') {
        return $self->{'bibentry'}->format_atitle;
    }
    return undef;
}

sub get {
    my ($self, $field) = @_;
    my $value = $self->get_plain($field);

    return ::tex_to_html($value);
}

sub key {
    my ($self) = @_;
    return $self->{'bibentry'}->key;
}


package main;

use constant BIBFILENAME => 'b2h.bib';

sub create_bbl {
    open F, ">", 'dummy.tex' or die ("Cannot open tex file for output: $!\n");
    print F << '    EOF';
    \documentclass{article}
    \bibliographystyle{plain}
    %\bibliographystyle{acm}
    \begin{document}
    \bibliography{b2h}
    \nocite{*}
    \end{document}
    EOF
    close F;

    open(my $oldout, ">&STDOUT") or die "Can't dup STDOUT: $!\n";
    open(STDOUT, '>', "/dev/null") or die "Can't redirect STDOUT: $!\n";

    system(qw{latex dummy}) == 0 or die "latex run failed: $?\n";
    system(qw{bibtex dummy}) == 0 or die "bibtex run failed: $?\n";

    open(STDOUT, ">&", $oldout) or die "Can't dup \$oldout: $!";
    close($oldout);
}

sub latex_format_bibs {
    create_bbl;
    my $formatted = {};
    open F, "<", 'dummy.bbl' or die ("Cannot open bbl file for input: $!\n");
    {
        local $/="";
        while (<F>) {
            if (/^\\begin\{thebibliography\}/) {
                next;
            } elsif (/^\\bibitem(?:\[.*?\])?\{(.*)\}/) {
                $formatted->{$1} = $_;
            } elsif (/^\\end\{thebibliography\}/) {
                last;
            } else {
                warn("Unexpected token in bbl: $_\n");
            }
        };
    };
    for my $k (keys %$formatted) {
        my @tokens = split /\\newblock/, $formatted->{$k};
        if (scalar @tokens >= 2) {
            my $t1 = shift @tokens;
            my $t2 = shift @tokens;
            my ($bibkey, $rest) = split(/\n/, $t1, 2);
            $formatted->{$k} = sprintf("%s \n ".'\textbf{%s} \newblock %s \newblock %s',
                $bibkey, $t2, $rest, join('\newblock', @tokens));
        }
    }
    return $formatted;
}

my $tmpdir;
END { chdir "/"; File::Path::remove_tree($tmpdir, {verbose => 0}) if defined ($tmpdir); }
$tmpdir = File::Temp->newdir(CLEANUP => 0);

open BIB, '>', $tmpdir."/".BIBFILENAME or die $!;
print BIB while (<>);
close BIB;

chdir($tmpdir) or die ("Cannot chdir to $tmpdir.\n");

my $bbl = latex_format_bibs;
#print Data::Dumper->Dump([$bbl]);

my $bib = new Text::BibTeX::File;
$bib->open(BIBFILENAME) or die "Cannot load bibfile: $!\n";
$bib->set_structure('Bib');

#sub do_tmpl {
#    my ($txt, $item, $vars) = @_;
#
#    my $h = { map { $_ => $item->exists($_) ? $item->get($_) : undef } @$vars };
#
#    my $res = Text::Template::fill_in_string(
#        $txt,
#        PREPEND => q{use strict;},
#        HASH => $h);
#    unless (defined $res) {
#        my $bibtexkey = $item->key;
#        warn "Couldn't construct template: $Text::Template::ERROR for $bibtexkey.\n";
#    };
#    return $res;
#}
#
#sub format_inproceedings($) {
#    my $entry = shift;
#    my @vars = qw{f_atitle f_authors booktitle pages address month year};
#
#    my $varlist = join(' ', map {'$'.$_} @vars);
#    my $template = "{ use vars qw{$varlist}; }\n";
#    $template .= <<'    EOF';
#    <strong>{$f_atitle}</strong><br />
#    <em>{$f_authors}</em><br />
#    In {$booktitle}{ if (defined($pages)) {
#        $OUT .= ", pp {$pages}";
#      }
#    }<br />
#    {$address}, {$month}, {$year}
#
#    EOF
#
#    return do_tmpl($template, $entry, \@vars);
#};

sub format_entry($) {
    my $entry = shift;

    my $bibtexkey = $entry->key;
    my @res;

    push @res, "<p>\n";
    #$bbl->{$bibtexkey} =~ s#/\}#\/ }#g;
    #$bbl->{$bibtexkey} =~ s#\\/#fo#g;
    push @res, tex_to_html($bbl->{$bibtexkey});
    if ($entry->exists('abstract')) {
        push @res, '<div class="abstract"><p />';
        push @res, $entry->get('abstract');
        push @res, '</div>';
    };

    return join("\n", @res);
};

my $entries = {};
my %month2number = (
    'January'   =>  1,
    'February'  =>  2,
    'March'     =>  3,
    'April'     =>  4,
    'May'       =>  5,
    'June'      =>  6,
    'July'      =>  7,
    'August'    =>  8,
    'September' =>  9,
    'October'   => 10,
    'November'  => 11,
    'December'  => 12 );

while (my $entry = new Text::BibTeX::Entry $bib) {
    next unless $entry->parse_ok && $entry->metatype == BTE_REGULAR;
    my $h = {};

    my $i = new Item($entry);
    $entries->{$i->key} = $h;

    my $is_selected = $i->exists('www_selected') && $i->get_plain('www_selected');
    if ($DO_SELECTED_ONLY && !$is_selected) {
        delete $entries->{$i->key};
        next;
    };

    my $year = $i->exists('year') ? $i->get_plain('year') : "unspecified";
    my $month = $i->exists('month') ? $month2number{$i->get_plain('month')} : undef;
    $month = 0 unless defined $month;
    $h->{'html'} = format_entry($i);
    $h->{'year'} = $year;
    $h->{'sort'} = sprintf("%s-%02d-%s", $year, $month, $i->key);
}

my $prev_year = '';
print <<EOF;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html 
 PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
div.abstract {padding-left:20px;}
.bibitem:before { content: "["; }
.bibitem:after { content: "]"; }
.bibitem { color:gray; font-size:small;"}
</style>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
</head>
<body>
EOF
for my $key (sort {- ($entries->{$a}->{'sort'} cmp $entries->{$b}->{'sort'}) } keys %$entries) {
    my $i = $entries->{$key};
    if ($prev_year ne $i->{'year'}) {
        $prev_year = $i->{'year'};
        print "<h2>$prev_year</h2>\n";
    };
    print $i->{'html'};
}
print <<EOF;
</p>
</body>
</html>
EOF

# vim:set et ts=4 sw=4 st=4:
